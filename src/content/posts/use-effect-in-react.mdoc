---
title: Effect를 react에서 사용하기
description: 'Effect가 무엇인지 알아보고, react에서 어떻게 사용할 수 있는지 알아보자.'
category: Effect
tags: ["프로그래밍", "react", "Effect", "typescript"]
published: 2025-05-09T06:34:06.353Z
draft: true
---

## Effect

이 글의 주제는 [__Effect__](https://effect.website/)인데, Effect를 모르는 사람들이 많이 존재하기에, 글의 주제에 들어가기에 앞서 빠르게 Effect에 대해 설명을 하고 넘어가 보겠습니다.

### Effect란?

Effect는 동기, 비동기 코드를 작성할 때 발생할 수 있는 오류와 사이드 이펙트, 의존성 등을 관리하기 위한 강력한 도구들을 제공하는 프레임워크입니다. 여기서 프레임워크라고 언급한 이유는 Effect는 콘솔, 입출력, Http API, 자료구조 등 프로그램을 만들기 위한 다양한 라이브러리들의 집합이기 때문입니다. Effect는 `Scala`의 [ZIO](https://zio.dev/)를 타입스크립트에 가져오기 위해 프로젝트가 시작되었으며, 이후 `fp-ts`와 합쳐져 현재까지 활발하게 개발되고 있습니다.

Effect의 가장 중요한 기능은 `Effect` 타입입니다. Effect의 시작은 `Effect`에서 시작해 `Effect`로 끝납니다. `Effect`는 다음과 같은 타입 시그니쳐를 가지고 있습니다.

```ts
Effect<Success, Error, Requirements>
```

`Success`는 `Effect`가 성공적으로 평가되었을 때 반환할 타입을, `Error`는 오류 타입을, `Requirements`는 해당 `Effect`가 평가되어야 할 때 필요한 의존성을 나타냅니다.

`Effect`의 가장 큰 특징 중 하나는 `ZIO`와 마찬가지로 동기 API와 비동기 API를 하나의 `Effect`로 합친 것입니다. 다만 `Effect`를 평가할 때는 다른 함수를 사용해야 합니다. 
동기 `Effect`를 평가하기 위한 함수는 `runSync`이며, 비동기 `Effect`를 평가하기 위한 함수인 `runPromise`는 비공기 함수로 `Promise`를 반환합니다.

```ts
Effect.runSync(effect) // 동기 Effect 평가
Effect.runPromise(effect) // 비동기 Effect 평가
```

Effect의 큰 장점 중 하나는 `Effect`의 합성이 굉장히 쉽고 강력하다는 것입니다. 모든 `Effect` 객체들은 `pipe`라는 합성을 하기 위한 메소드를 가지고 있고, 동일한 기능을 수행하는 `Effect.pipe` 함수도 존재합니다.

```ts
const effect = Effect.succeed(1)
    .pipe(
        Effect.map((n) => n + 1),
        Effect.map((n) => n > 1)
    );
```

`pipe`와 함께 자주 자주 사용되는 기능은 `Effect.gen`입니다. `Effect.gen`은 제너레이터를 이용해 `Effect`를 평가해 쉽게 effectful한 코드를 작성할 수 있게 해주는 도구입니다. `Effect.gen`은 `pipe`와 다르게 일반 타입스크립트 제너레이터를 사용하므로 평범한 루프 및 분기 처리 등을 사용할 수 있습니다.

```ts
const effect = Effect.succeed(1)
const effect2 = Effect.succeed(2)
const failedEffect = Effect.fail(3)

const gen = Effect.gen(function*() {
    const n1 = yield* effect; // 1
    const n2 = yield* effect2; // 2
    const n3 = yield* failedEffect; // 오류, 즉시 종료

    for (let i = 0; i < 10; ++i) {
        const n = yield* effect;
        console.log(n);
    }

    return n1 + n2 + n3;
})
```

위의 코드에서 `yield* failedEffect`는 실패하는 `Effect`를 평가하는 것을 알 수 있습니다. 이 때 `Effect.gen`은 실패하는 즉시 `Error`을 반환하는 short circuit 동작을 합니다.

더 자세한 내용은 [Effect Docs](https://effect.website/docs)에서 확인하면 됩니다.

### 왜 Effect를 사용해야 할까?

Effect에 대해 간단히 알아봤는데, 그렇다면 왜 Effect를 사용하는걸까요? 이는 [Why Effect?](https://effect.website/docs/getting-started/why-effect/)에 잘 나와있습니다.

간단히 설명하자면 기존의 타입스크립트 코드는 오류가 발생할 지점을 알 수 없지만, Effect에서는 타입 레벨에서 관리가 가능하다는 것이 주요한 이유입니다.

```ts
function mayFailParse<T>(jsonBlob: string): T {
    return JSON.parse(jsonBlob) as T;
}
```

위의 `mayFailParse` 함수는 json으로 직렬화가 가능한 문자열을 입력으로 받아 `T` 타입의 값을 반환할 수 있는 함수입니다. 이 함수에는 몇 가지 큰 문제점이 존재합니다.

우선 가장 먼저 해결해야 하는 문제는 `JSON.parse`는 오류가 발생할 수 있는 함수라는 것입니다. `JSON.parse`는 json으로 직렬화가 불가능한 입력값을 받을 경우 오류를 발생시키기 때문에, 코드를 `try catch`로 묶어 오류를 해결해야 합니다.

```ts
function mayFailParse<T>(jsonBlob: string): T | null {
    try {
        return JSON.parse(jsonBlob) as T;
    } catch (e) {
        return null;
    }
}
```

오류가 발생하지 않도록 처리했다는 점에서 첫 번째보다 나아졌습니다. 그런데 이 함수는 오류가 발생한다면 `null`을 반환하도록 했는데, 코드에서 다양한 오류가 발생할 수 있다면 호출자에게 어떠한 오류가 발생했는지 알려줘야 할 수도 있습니다. 이를 처리하기 위해 다음과 같은 에러 태그를 반환할 수 있습니다.

```ts
class JSONParseError {
  constructor(public tag: string) {}
}

function mayFailParse<T>(jsonBlob: string): T | JSONParseError {
  try {
    return JSON.parse(jsonBlob) as T;
  } catch (e) {
    if (e instanceof SyntaxError) {
      return new JSONParseError("SyntaxError");
    }
    if (e instanceof TypeError) {
      return new JSONParseError("TypeError");
    }
    return new JSONParseError("UnknownError");
  }
}
```

이제 `mayFailParse`는 어떤 오류가 발생할 수 있는지 호출자에게 알릴 수 있습니다. 그런데 만약 여기에 `mayFailParse`와 같이 오류가 발생할 수 있는 변환 함수를 추가하려고 한다면 어떻게 될까요?

```ts
class JSONParseError {
  constructor(public tag: string) {}
}

class TransformError {}

function mayFailParse<T, U>(
  jsonBlob: string,
): U | JSONParseError | TransformError {
  try {
    const json = JSON.parse(jsonBlob) as T;

    try {
      return transform(json);
    } catch (e) {
      return new TransformError();
    }
  } catch (e) {
    if (e instanceof SyntaxError) {
      return new JSONParseError("SyntaxError");
    }
    if (e instanceof TypeError) {
      return new JSONParseError("TypeError");
    }
    return new JSONParseError("UnknownError");
  }
}
```

`transform`에서 오류가 발생할 수 있기 때문에 `TransformError`를 추가하고, 반환 타입에도 `TransformError`를 명시해줘야 합니다. `JSONParseError`와 `TransformError`를 하나의 `Error` 클래스로 합쳐 하나의 `Error` 타입을 반환할 수도 있지만, 그걸 제외하더라고 중첩되는 `try catch`문, 복잡한 호출자측 오류 회복 등 다양한 문제가 존재합니다.

Effect는 이러한 문제를 강력한 패턴으로 해결해줍니다.

```ts
class JSONParseError {
  constructor(public tag: string) {}
}

class TransformError {}

function mayFailParse(jsonBlob: string) {
    return Effect.try
}
```